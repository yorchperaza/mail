#!/usr/bin/env php
<?php
declare(strict_types=1);

use App\Service\OutboundMailService;
use App\Service\Ports\MailQueue;
use Predis\Client as PredisClient;

$container = require __DIR__ . '/../bootstrap.php';

/** @var MailQueue $queue */
$queue = $container->get(MailQueue::class);
/** @var OutboundMailService $service */
$service = $container->get(OutboundMailService::class);

// Get Redis (phpredis or Predis)
$redis = null;
if ($container->has(Redis::class)) {
    /** @var Redis $redis */
    $redis = $container->get(Redis::class);
} elseif ($container->has(PredisClient::class)) {
    /** @var PredisClient $redis */
    $redis = $container->get(PredisClient::class);
} else {
    fwrite(STDERR, "[worker] No Redis client found in container.\n");
    exit(1);
}

// Ensure stream/group exists if your queue exposes it
if (method_exists($queue, 'ensureGroup')) {
    $queue->ensureGroup();
}

$stream   = method_exists($queue, 'getStream') ? $queue->getStream() : ($_ENV['MAIL_STREAM'] ?? 'mail:outbound');
$group    = method_exists($queue, 'getGroup')  ? $queue->getGroup()  : ($_ENV['MAIL_GROUP']  ?? 'senders');
$consumer = gethostname() . '-' . getmypid();

$blockMs     = 5000;   // block 5s
$batch       = 20;     // max msgs / read
$claimIdleMs = 60000;  // claim msgs idle > 60s
$maxRetries  = 5;

echo "[worker] listening stream={$stream} group={$group} consumer={$consumer}\n";

// helpers to unify phpredis / Predis
$readGroup = function ($streams, int $count, int $blockMs) use ($redis, $group, $consumer) {
    if ($redis instanceof Redis) {
        // phpredis
        return $redis->xReadGroup($group, $consumer, $streams, $count, $blockMs) ?: [];
    }
    // Predis
    // Build XREADGROUP GROUP <group> <consumer> COUNT <count> BLOCK <ms> STREAMS <stream> <id>...
    $cmd = ['XREADGROUP','GROUP',$group,$consumer,'COUNT',(string)$count,'BLOCK',(string)$blockMs,'STREAMS'];
    foreach ($streams as $s => $_) $cmd[] = $s;
    foreach ($streams as $_ => $id) $cmd[] = $id;

    /** @var PredisClient $redis */
    $raw = $redis->executeRaw($cmd);
    // Normalize Predis reply to match phpredis shape: [ stream => [ entryId => [field=>value,...], ... ] ]
    $out = [];
    if (!is_array($raw)) return $out;
    foreach ($raw as $streamArr) {
        // $streamArr = [ streamName, [ [entryId, [field, value, field, value...]], ... ] ]
        if (!is_array($streamArr) || count($streamArr) < 2) continue;
        $sName = $streamArr[0];
        $entries = $streamArr[1] ?? [];
        foreach ($entries as $e) {
            $entryId = $e[0] ?? null;
            $kv      = $e[1] ?? [];
            $fields  = [];
            for ($i=0; $i < count($kv); $i+=2) {
                $fields[(string)$kv[$i]] = (string)($kv[$i+1] ?? '');
            }
            if ($entryId) $out[$sName][$entryId] = $fields;
        }
    }
    return $out;
};

$xAck = function (string $stream, string $group, array $ids) use ($redis) {
    if ($redis instanceof Redis) return $redis->xAck($stream, $group, $ids);
    /** @var PredisClient $redis */
    return $redis->executeRaw(array_merge(['XACK',$stream,$group], $ids));
};

$xPending = function (string $stream, string $group, int $count) use ($redis) {
    if ($redis instanceof Redis) {
        return $redis->xPending($stream, $group, '-', '+', $count) ?: [];
    }
    /** @var PredisClient $redis */
    $raw = $redis->executeRaw(['XPENDING',$stream,$group,'-','+',(string)$count]);
    // Predis returns [ [id, consumer, idleMs, deliveries], ... ]
    return is_array($raw) ? $raw : [];
};

$xClaim = function (string $stream, string $group, string $consumer, int $minIdle, array $ids) use ($redis) {
    if ($redis instanceof Redis) {
        try { return $redis->xClaim($stream, $group, $consumer, $minIdle, $ids, ['JUSTID'=>false]); } catch (\Throwable) { return null; }
    }
    /** @var PredisClient $redis */
    $cmd = array_merge(['XCLAIM',$stream,$group,$consumer,(string)$minIdle], $ids);
    try { return $redis->executeRaw($cmd); } catch (\Throwable) { return null; }
};

$xAdd = function (string $stream, array $fields) use ($redis) {
    if ($redis instanceof Redis) {
        return $redis->xAdd($stream, '*', $fields);
    }
    /** @var PredisClient $redis */
    $cmd = ['XADD',$stream,'*'];
    foreach ($fields as $k=>$v) { $cmd[] = (string)$k; $cmd[] = (string)$v; }
    return $redis->executeRaw($cmd);
};

while (true) {
    try {
        // 1) Claim long-idle pending messages (crashed consumers)
        foreach ($xPending($stream, $group, 50) as $p) {
            // phpredis: [id, consumer, idle, deliveries]
            // Predis:   same order
            $id         = $p[0] ?? null;
            $idle       = (int)($p[2] ?? 0);
            if ($id && $idle >= $claimIdleMs) {
                $xClaim($stream, $group, $consumer, $claimIdleMs, [$id]);
            }
        }

        // 2) Read new + claimed messages
        $msgs = $readGroup([$stream => '>'], $batch, $blockMs);
        if (!$msgs || empty($msgs[$stream])) continue;

        foreach ($msgs[$stream] as $entryId => $fields) {
            $payloadRaw = $fields['payload'] ?? ($fields['data'] ?? null); // support both keys
            $payload    = is_string($payloadRaw) ? json_decode($payloadRaw, true) : null;
            $retries    = isset($fields['retries']) ? (int)$fields['retries'] : 0;

            if (!is_array($payload) || !isset($payload['message_id'])) {
                // bad message -> ack and continue
                $xAck($stream, $group, [$entryId]);
                continue;
            }

            try {
                $service->processJob($payload);
                $xAck($stream, $group, [$entryId]);
            } catch (\Throwable $e) {
                $retries++;
                if ($retries > $maxRetries) {
                    // Dead-letter
                    $xAdd($stream . ':dlq', [
                            'payload' => (string)$payloadRaw,
                            'error'   => $e->getMessage(),
                            'at'      => (new \DateTimeImmutable('now', new \DateTimeZone('UTC')))->format(DATE_ATOM),
                    ]);
                    $xAck($stream, $group, [$entryId]);
                } else {
                    // Re-queue with retries
                    $xAdd($stream, ['payload' => (string)$payloadRaw, 'retries' => (string)$retries]);
                    $xAck($stream, $group, [$entryId]);
                }
            }
        }
    } catch (\Throwable $e) {
        fwrite(STDERR, "[worker] error: {$e->getMessage()}\n");
        usleep(500_000);
    }
}
